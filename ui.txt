VibeCode MVP — UI Specification
================================

Overview
--------
The MVP UI is split into three primary parts that coexist within an Electron shell: Part A (Workspace Assembly), Part B (Code Environment), and Part C (Community Library). A global chrome (top command bar, status tray, notifications, profile menu) keeps state consistent while enabling fast context switching. Dark mode is default with a high-contrast light theme toggle.

Global Interaction Principles
-----------------------------
* **Smooth drag-and-drop + physics easing** for all module movements and canvas interactions.
* **Keyboard-first workflows:** `⌘K` command palette, `⌘P` quick open, `⌘B` toggle left rail, `Space` quick preview, `Esc` clear selections.
* **Context-aware tooltips** that surface metadata, validation hints, and shortcuts.
* **Non-blocking notifications** slide in from the upper-right, summarizing LLM actions, build status, and module import results.
* **Undo/redo timeline** (`⌘Z` / `⇧⌘Z`) spanning module graph edits, property changes, and generated glue code.
* **Collaborative-ready presence shells** (avatars + “coming soon” tooltip) so adding real-time collab later does not disturb layout.
* **Responsive layout** scales down to 1280px while keeping panels dockable/stackable.

Part A — Workspace & Module Assembly
------------------------------------
### Layout
* Three-column grid: 280px Module Library (left), fluid Canvas (middle), 320px Properties Panel (right).
* Panels are resizable and can be collapsed via hover handles or keyboard shortcuts.
* Breadcrumb strip above the canvas shows the current flow path (e.g., `Auth > Login > Profile`).

### Left Panel — Module Library (Local Only in MVP)
* Module cards list name, type badge (Auth/Data/UI/Comms), short description, dependency icons, and last updated timestamp.
* Filters: search, tag pills, “Recently used,” “Favorites,” “Imported.”
* Drag handles remain visible on hover; long-press on touchpads activates drag.
* Context menu per module: Preview, Add to Canvas, Pin to Favorites, View Metadata.
* Inline preview drawer (slides over the panel) shows metadata JSON, sample screenshots, and doc excerpt.
* QoL: quick “Replace on canvas” option when dragging a module onto an existing node of the same type.

### Middle Panel — Drag-and-Drop Module Canvas
* Nodes render as cards with icon, title, status dot (synced / dirty), and port handles for inputs/outputs.
* Auto-lane layout groups screens horizontally and utilities vertically; users can override via drag.
* Connection drawing: click+drag from output handle to input target; snapping guidelines prevent miswiring.
* Interaction set:
	- Multi-select via marquee drag or `Shift+click`.
	- Alignment tools (distribute, tidy up) similar to Figma.
	- Mini-map in the bottom-right with zoom slider and “fit to view.”
	- Edge annotations for describing logic (e.g., “redirect if success”).
* Canvas sidebar shows warnings: missing inputs, circular dependencies, unmet module requirements.
* QoL: ghost preview of auto-generated route order, inline “Generate Glue Code” chip once a connection is complete, and hover tooltips summarizing linked inputs/outputs.

### Right Panel — Property & Variable Editor
* Structured tabs: Inputs, Outputs (read-only), Methods, Theme, Integrations.
* Each input row offers field type hints, default values, inline validators, and revert buttons.
* Secret fields (API keys) hide values with reveal-once tokens and copy buttons.
* Method tab lists callable actions with “Test call” buttons that simulate sample data.
* Theme tab exposes color pickers with preview chips sync’d to canvas nodes.
* QoL: change log pill showing the last three modifications, quick diff toggle to see pending glue code patches, and “Apply to similar modules” bulk action.

### Module Graph Inspector (Docked Bottom of Part A)
* Collapsible tray describing all modules currently on the canvas, their dependencies, and connection health.
* Columns: Module, Inputs satisfied, Outputs used, Glue status, LLM notes.
* Allows disabling/enabling routing edges and rerunning glue for a subset of modules.

Part B — Code Environment (VS Code-like)
-----------------------------------------
Part B intentionally mirrors VS Code almost one-to-one so developers feel instantly at home. The window chrome, activity bar icons, editor tabs, breadcrumbs, panel arrangement, color themes, and command palette behave like stock VS Code, with only lightweight brand accents (logo, custom accent color).

### Core Areas
* **Activity Bar & File Explorer:** identical affordances to VS Code—context menus, drag reorder, Git badges, file diff indicators.
* **Monaco Editor Tabs:** supports split panes, peek definitions, inline diagnostics, multi-cursor editing, and Dart/Flutter syntax highlighting.
* **Status Bar:** displays branch, sync state, Flutter device picker, build progress, LLM patch status.
* **Integrated Terminal:** pre-configured tasks (`flutter pub get`, `flutter run`, `flutter build`) with shortcut buttons pinned above the terminal.
* **Module Graph Panel:** docked beneath the explorer (can be detached). Lists modules, their source files, last glue generation timestamp, and “Open associated file” buttons.

### LLM Patch Workflow UI
* Selecting code + hitting “Request AI Patch” opens a VS Code-style diff sidebar showing context, prompt summary, and expected edits.
* Incoming patches appear as inline diff decorators; user can accept per hunk, compare, or revert.
* Activity feed logs each patch with module references, token usage estimate, and ability to regenerate.

### Quality-of-Life Enhancements
* Command palette entries for “Jump to module in canvas,” “Open module metadata,” “Show recent glue patches.”
* Breadcrumb hover previews show module relationships and quick actions (regenerate glue, open docs).
* Auto-save with dirty tab indicators mirrors VS Code behavior; offline banner warns when API calls will queue.
* Debug controls pinned for Flutter hot-reload/hot-restart with status lights.
* Optional Zen Mode hides Part A/C while keeping VS Code look intact.

Part C — Community Library (Figma Community-like)
-------------------------------------------------
This section visually and behaviorally references Figma Community: masonry grid of module cards, large search header, creator info, and social proof cues.

### Layout & Navigation
* Left rail filters (Categories, Use cases, Compatibility) similar to Figma’s tagging system.
* Primary content area: responsive grid (2–4 columns) of module tiles with hero image/animation, name, type badge, rating stars (future), and “Imported” state chips.
* Sticky search + sort bar with suggestions (“Auth”, “Chat”, “Featured”).

### Module Detail View
* Opens as a full-height side sheet (like Figma’s module preview) containing screenshots, live metadata JSON viewer, dependency list, release notes, and “Import to Workspace” CTA anchored at bottom.
* Tabs: Overview, Code Snippets, Reviews (coming soon), Version History.
* Related modules carousel encourages discovery.

### Interactions & QoL
* Hover reveals quick actions: Preview, Import, Save for Later.
* “Save for Later” syncs to local favorites and optionally cloud profile.
* Users can copy install instructions, share a module link, or view licensing info.
* Inline status banners (e.g., “Requires Supabase key”) warn before import.
* Import confirmation toast includes shortcut to jump directly to Part A canvas.

Cross-Part Quality-of-Life Features
----------------------------------
* **Universal search (`⌘K`)** traverses modules, files, docs, and actions with context-aware results grouped by Part.
* **Onboarding checklist** floats near bottom-left, guiding new users through “Import module → Place on canvas → Generate glue → Test build.”
* **Persistent workspace sessions** remember open panels, split views, zoom level, and selected modules across launches.
* **Inline help mode** overlays hotspots explaining each control; accessible anytime via `⇧/?`.
* **Performance hints** (e.g., “Canvas getting heavy, collapse groups?”) keep large projects usable.
* **Accessibility support:** high-contrast theme, focus outlines, screen reader labels for every interactive element, reduced motion toggle.

This UI plan ensures Part B feels nearly identical to VS Code, Part C channels Figma Community’s discovery experience, and every natural user interaction—from dragging modules to accepting LLM patches—is addressed with thoughtful quality-of-life touches.
