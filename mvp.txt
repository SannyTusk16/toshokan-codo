====================================================================
MVP (Phase 1)
=============

MVP must include:

1. Part B – VS Code-like environment
   Monaco-based editor inside Electron
   File explorer
   Git support (forked from VS Code or embedded)

2. Part A – Workspace
   Left: Module Library
   Middle: Drag-and-drop module canvas
   Right: Variable configuration panel

Flutter Modules implemented:

Google Auth via Firebase
Firebase Firestore data retrieval + write
Login screen module
Signup screen module
Profile section module
Chat interface module
Gemini chat module (API-based)

Minimal Flow:
User drags modules → connects them → AI generates glue code → user runs Flutter build locally → app works

3. Module Library
(figma community type - ui)
   Basic modules published
   Hosted in Supabase
   Public + private distinction

4. LLM Integration Layer
   Supports Gemini 2.0 Flash
   User can supply API keys for:
   OpenAI
   Claude
   More providers

5. Module JSON Spec
   Modules stored with metadata + code folder
   Interconnections handled by LLM

====================================================================
VIBE-CODE MVP SPECIFICATION
===========================

This MVP establishes the foundational system of VibeCode: a modular, LLM-powered application builder designed around assembling pre-built functional modules instead of writing entire applications manually. The MVP focuses on operationalizing the core workflows required to build simple Flutter applications using drag-and-drop modules, visual configuration, and minimal LLM-generated glue code.

The MVP consists of three major components:
Part A – Workspace Panel
Part B – VS Code-like Code Environment
Part C – Module Library
The LLM backend: Gemini 2.0 Flash

====================================================================

1. PART B — VS CODE–LIKE ENVIRONMENT
   ====================================================================

The MVP must include a functioning code environment that feels familiar to developers but is optimized for module-based workflows.

Key requirements:

### 1.1 Editor Core

• Monaco Editor embedded in the Electron shell
• Syntax highlighting for Dart and Flutter
• Basic Flutter language features (autocomplete, formatting, error prompts)
• Support for file tree browsing (local project structure)
• Ability to open and modify module code files
• Code diff view for LLM-generated patches
• Basic terminal integration to run:
flutter pub get
flutter run
flutter build

### 1.2 Module Graph Panel (Bottom Section)

A new custom panel occupying the lower half of the file explorer.

Displays:
• All modules currently used in the project
• Their metadata (name, inputs, outputs, dependencies)
• Connection map (A output → B input links)
• Ability to click a module and open its code
• Ability to regenerate glue code for a module
• Ability to disable or enable routing connections

### 1.3 LLM Code Editing Mode

The MVP includes a restricted LLM editing mode:
• User selects a module connection or file block
• System generates a "patch request"
• Gemini 2.0 Flash returns only the required code edits
• System applies patches using diff operations

This ensures low token usage and prevents overwriting full files.

====================================================================
2. PART A — WORKSPACE AND MODULE ASSEMBLY
=========================================

This part is the heart of the modular app-building experience.

The workspace must have a three-column layout:

### 2.1 Left Panel — Module Library (Local Only in MVP)

Displays the modules available for Flutter (from Part C).
Allows dragging modules into the workspace.

For MVP:
• GoogleAuthModule
• FirebaseDatabaseModule
• LoginPageModule
• SignupPageModule
• ProfileSectionModule
• ChatInterfaceModule
• GeminiChatModule

### 2.2 Middle Panel — Drag-and-Drop Module Canvas

A visual representation of the app flow.
Screen modules appear as nodes.
Backend/auth modules appear as utility blocks.

Features:
• Drag module from left → drop into canvas
• Auto-generated routing (e.g., Login → Home → Profile)
• Ability to connect module outputs to other modules’ inputs
• Ability to reorder screens
• Ability to create edges between modules (logic flow)

The canvas acts like a workflow builder combining Figma + Retool + FlutterFlow’s logic linking.

### 2.3 Right Panel — Property and Variable Editor

Displays details of the selected module:
• Inputs (editable)
• Outputs (read-only)
• Methods (view)
• Theme variables
• API keys
• Module configurations
For example:
GoogleAuthModule → redirectOnSuccess: "/home"
LoginPageModule → enableCaptcha: true

When the user modifies these values, the LLM generates only the required code changes (small patch requests).

====================================================================
3. PART C — MODULE LIBRARY (MVP VERSION)
========================================

Minimum requirements:

### 3.1 Module Repository

A simple hosted database or even a JSON file in the repo for MVP.

Contains a list of Flutter modules, each with:
• Metadata JSON
• Code folder
• Documentation text

For the MVP, no paid modules, no encryption, no community marketplace.

### 3.2 Publishing Workflow

Include a minimal interface inside Part C:
• Display modules
• Click to preview (show metadata + code snippet)
• Button: “Import to Workspace”

This is sufficient to demonstrate the concept.

====================================================================
4. LLM BACKEND — GEMINI 2.0 FLASH
=================================

Gemini 2.0 Flash is the only model integrated in the MVP.

Features required:

### 4.1 LLM Manager

• Sends structured prompts describing modules
• Receives patch-based code edits
• Ensures the LLM never receives entire 3,000-line files
• Enforces the “edit-section-only” approach

### 4.2 Glue Code Generator

The system sends Gemini:
• The metadata of Module A
• The metadata of Module B
• The current JSON project graph
• Small chunks of relevant code
• The required connection (A.output → B.input)

Gemini responds with:
• Missing imports
• Missing function calls
• Routing entries
• Small snippets to insert
• Logic linking the modules

### 4.3 Token Optimization

Gemini only receives:
• Metadata JSON
• 20–50 lines of code context
• No full project files
• No heavy diffs
Result: extremely low token usage.

====================================================================
MVP MODULE SET
==============

The following modules must exist with real, usable Flutter code.

### Auth & Data

1. GoogleAuthModule
2. FirebaseDatabaseModule (CRUD operations)

### UI Widgets & Screens

3. LoginPageModule
4. SignupPageModule
5. ProfileSectionModule

### Communication

6. ChatInterfaceModule (UI only, simple input/output)
7. GeminiChatModule (LLM chat using Gemini API)

Each module must include:
• metadata.json
• code files (Flutter/Dart)
• inputs and outputs
• dependencies
• documentation

Example flows a user can build in MVP:
GoogleAuth → Login → Home → Profile
FirebaseDataModule → ProfileSection
ChatInterface → GeminiChat

====================================================================
FULL USER FLOW IN MVP
=====================

1. User opens VibeCode MVP
2. Goes to Module Library (Part C)
3. Imports:
   • GoogleAuth
   • Login
   • Signup
   • Profile
   • Chat Interface
4. Drags these into Workspace Canvas (Part A)
5. Connects flows:
   Login → Home → Profile
   Profile → ChatInterface
6. Configures GoogleAuth redirect to Home
7. Presses "Generate Code"
8. Gemini Flash creates glue code
9. User switches to Part B
10. Code compiles
11. User runs Flutter build
12. App works end-to-end

====================================================================
SCOPE LIMITATIONS FOR MVP
=========================

The MVP does not include:
• Full marketplace
• Paid module encryption
• Versioning
• User-added models
• Backend admin dashboard
• Real-time collaboration
• Custom module builder
These come later.

====================================================================
SUMMARY
=======

The MVP delivers the core promise of VibeCode:
Drag in modules → configure → LLM glues code → your Flutter app is ready.

It includes:
Part A: Workspace with drag-and-drop module flow and configuration
Part B: VS Code-like environment with patch-based LLM code edits
Part C: Minimal module library
LLM: Gemini 2.0 Flash for all glue operations

This MVP is enough to prove the concept, show investors, onboard early users, and begin building a community around module publishing.

If you want, I can now draft:
• The complete PRD
• Technical architecture diagrams
• A milestone roadmap
• A detailed breakdown of each module’s metadata format
• Investor pitch version of the MVP summary
